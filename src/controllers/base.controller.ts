import { Response } from 'express'
import mongoose = require('mongoose')
import { env } from '../yts.env';
import { IModel } from '../interfaces/IModel';
import { IFindPaginationQuery, IPopulate } from '../interfaces/yts.types';
import { BaseModel } from '../models/base.model';

/* Provides functions to be used with express routes. Serves common CRUD functionality. */
export class BaseController {
    public useModReturnNew = { useFindAndModify: false, new: true }
    public model: IModel;
    constructor(model: IModel) {
        this.model = model;
    }
    
    private formattedRes = (res:any, message?:string) =>{
        return {
            body: res,
            message: message || 'ok',
            success: !!res
        }
    }

    /**
    * Sends the document as JSON in the body of response, and sets status to 200
    * @param doc the MongoDB document to be returned to the client as JSON
    * @param res the response object that will be used to send http response
    */
    jsonRes(doc: any, res: Response, statusCode=200,message:string = 'Document created successfully') {
        return res.status(statusCode).json(this.formattedRes(doc, message));
    }

    private formattedErrorRes = (err:mongoose.Error | any):string[] => {
        try {
            let retErr:string[] = [];
            if(err.name === 'ValidationError') retErr = (Object.keys(err.errors) || []).map(val => <string>err.errors[val].message);
            if(err.code === 11000) retErr = Object.keys(err?.keyValue || []).map(key => `'${err.keyValue[key]}' already exist with us.`);
            return (retErr.length > 0) ? retErr : [err.message];
        } catch (error) {
            return [err.message];
        }
    }

    public handleHttpError(err:any,res:Response,message:string[] | string,statusCode=400){
        return res.status(statusCode).json({
            error:err,
            success:false,
            message:message
        })
    }

    /**
     * @param err error object of any type generated by the system
     * @param message custom response message to be provided to the client in a JSON body response ({error:'message'})
     * @param res response object to be used to to send 
     * @param status custom status code, defaults to 500
     */    
    public errRes(err: any, res: Response, message = 'Server Error', status = 500) {
        return res.status(status).json({ error: message, success: false, err: err, message: this.formattedErrorRes(err) });
    }

    /* Creates a new document */
    create(res: Response, document: any, populate?: IPopulate, errMsg = 'Failed to create the document.') {
        this.model.create<mongoose.Document>(document).then((doc: mongoose.Document) => {
            if (populate) {
                doc.populate(populate).then(populatedDoc => {
                    return this.jsonRes(populatedDoc, res)
                }).catch(err => { return this.errRes(err, res, errMsg) })
            } else {
               return this.jsonRes(doc, res)
            }
        }).catch(err => { return this.errRes(err, res, errMsg) })
    }

    /* Returns all documents of model*/
    find(res: Response, populate?: IPopulate, errMsg = 'Failed to find documents') {
        this.model.find(populate).then(doc => { return this.jsonRes(doc, res) }, err => this.errRes(err, res, errMsg) );
    }

    /**returns the paginated document. */
    paginatedFind(res:Response, query:any = {}, paginationQuery?: IFindPaginationQuery, populate?:IPopulate){
        const page_size = paginationQuery?.page_size || 20, page_number = paginationQuery?.page_number || 1;
        return populate ? 
            this.model.mongooseModel.find(query)
            .limit(page_size).skip((page_number - 1)*page_size).populate(populate).exec()
            .then(doc => this.jsonRes(doc, res))
            .catch(err => this.errRes(err,res,'Failed to find the document.'))
        : 
            this.model.mongooseModel.find(query)
            .limit(page_size).skip((page_number - 1)*page_size).exec()
            .then(doc => this.jsonRes(doc, res))
            .catch(err => this.errRes(err,res,'Failed to find the document.'));
    }

    /* Returns single document of model specified by _id. */
    findById(res: Response, documentId: string, populate?: IPopulate, errMsg = `Failed to find document ${documentId}`) {
        this.model.findById(documentId, populate).then(doc => { return this.jsonRes(doc, res) }, err => this.errRes(err, res, errMsg) ).catch( err => {this.errRes(err, res, 'Failed to retrieve doc')});
    }

    /* Returns single document from given model that matches the query. */
    findOne(res: Response, query: any, populate?: IPopulate, errMsg = `Failed to find document ${query}`) {
        this.model.findOne(query, populate).then(doc => { return this.jsonRes(doc, res) }, err => this.errRes(err, res, errMsg) );
    }

    findMany(res: Response, query: any, populate?: IPopulate, errMsg = `Failed to find document ${query}`) {
        this.model.findMany(query, populate).then(doc => { return this.jsonRes(doc, res) }, err => this.errRes(err, res, errMsg) );
    }

    /* Updates single document */
    updateById(res: Response, documentId: string, document: any, populate?: IPopulate | IPopulate[], errMsg = `Failed to update document ${documentId}`) {
        this.model.updateById(documentId, document, populate).then(doc => { return this.jsonRes(doc, res) }, err =>  this.errRes(err, res, errMsg));
    }

    /* Deletes a single document selected by id */
    deleteById(res: Response, documentId: string, errMsg = `Failed to delete document ${documentId}`) {
        this.model.deleteById(documentId).then(doc => { return this.jsonRes(doc, res) }, err => this.errRes(err, res, errMsg) );
    }
}